# Common Concepts

## 1. 变量和可变性

Rust 中的变量默认是不可变的（immutable），编译器会保证它的值不会改变，这使得代码更容易追踪。必要时可以手动使其可变。

```rust
let mut x = 5;
```

当变量是不可变的时，一旦一个值绑定到到该变量，值就不能更改了。

例：

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);

    x = 6;
    println!("The Value of x is: {}", x);
}
```

`cargo run` 运行，报错：

```bash
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:5:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
...
5 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
```

这除了防止 bug 外，还有其它的权衡：

- 当使用大结构体时，原地修改数据要比复制并返回新实例要快。
- 使用小结构体时，创建新的实例和函数式的写法使代码的可读性更强。
- 这需要在性能和可读性之间作出权衡。

### 1.1 变量和常量的区别

常量也是绑定到名称且不允许更改的值，它和变量的区别：

- 常量永远是不可变的，不能像变量似地使用 `mut` 来使其成为可变的。
- 声明常量使用 `const` 关键字，而且**必须注明值的类型**。
- 常量可以在任意作用域中声明，包括全局作用域。
- 最后，常量只能设置为常量表达式，不能是函数调用的结果或其它只能在运行时计算出的值。

示例：

```rust
const MAX_POINTS: u32 = 100_000;
```

- Rust 常量的命名规范是使用下划线分隔的大写字母单词。
- 可以在数字字面值中插入下划线来提升可读性。

### 1.2 遮蔽 (shadowing)

可以声明一个与前面变量同名的新变量，Rust 中这叫做第一个变量被第二个变量遮蔽 (shadowing) 了。可以使用 `let`关键字来多次遮蔽：

```rust
fn main() {
    let x = 5;
    let x = x + 1; // 6
    let x = x * 5; // 30
    println!("The Value of x is: {}", x);
}
```

遮蔽和将变量标记为 `mut`不同，在不使用 `let`的情况下赋值给这个变量将导致编译时错误。通过使用 `let` 可以对一个值进行一些转换，不过转换完成后，变量仍是不可变的。

遮蔽与 mut 的其它不同：因为当再次使用 let 关键字时是创建了一个新变量，这时可以改变值的类型，但复用这个名称。

如，将字符串类型改为数字类型：

```rust
let spaces = "    ";
let spaces = spaces.len();
```

但如果使用 mut 的话，编译时会报错：

```rust
let mut spaces = "    ";
spaces = spaces.len();
```

报错：

```bash
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`

error: aborting due to previous error
```

## 2. 数据类型

Rust 是静态类型语言，意味着必须在编译时知道所有变量的类型。编译器可以根据变量的值和使用方式来推断其类型，但在可能有多种类型的情况下，需要注明值的类型。

比如想将字符串转换为数字时，必须注明其类型：

```rust
let guess: u32 = "42".parse().expect("Not a number.");
```

如果把 u32 去掉，会报错：

```bash
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number.");
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error
```

### 2.1 标量 (Scalar) 类型

**标量**（scalar）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。

#### 2.1.1 整数类型

相比 Go，Rust 多了个 128 类型的整数。`isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

可以使用任何一种形式编写整数字面值。除 byte 以外的所有整数字面值允许使用类型后缀，例如 `57u8`，同时也允许使用 `_` 做为分隔符以方便读数，例如`1_000`。

Rust 的**整数类型默认**是 `i32`：它通常最快，甚至在 64 位系统上也是。`isize` 或 `usize` 主要作为某些集合的索引

> 整数溢出：
>
> - 如果在 debug 模式，整数溢出时编译器会报错。
> - 如果在 release 模式，不会报错，编译器会执行 *two’s complement wrapping*。例如，如果是 u8 类型，256 会变成 0, 257 变成 1。。。

#### 2.1.2 浮点类型

Rust 的浮点类型有 `f32` 和 `f64`，**默认类型**是 `f64`。`f32` 是单精度浮点数，`f64` 是双精度浮点数。

#### 2.1.3 数字操作

加减乘除和取余，直接看代码：

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```

#### 2.1.4 布尔类型 (Boolean)

布尔类型占 1 字节大小。

#### 2.1.5 字符类型 (Character)

Rust 的 `char` 类型是语言中最原生的字母类型，由使用单引号，不同于字符串使用双引号。

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

Rust 的 `char` 类型的大小为四个字节，并代表了一个 Unicode 标量值。

### 2.2 复合类型

Rust 有两个原生的复合类型：元组（tuple）和数组（array）。

#### 2.2.1 元组类型 (Tuple)

元组是将**多种类型的多个值**组合为一个复合类型的一般方法。

- 元组的长度固定，一旦声明，就不会再扩容或缩容。
- 元组中不同值的类型不是必须一致。

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

要从元组中获取单个值，使用模式匹配来解构 (destructuring) 元组的值：

```rust
fn main() {
    let tup: (i32, f64, u8) = (24, 2.4, 42);
    let (x, y, z) = tup;

    println!("x: {}", x);
    println!("y: {}", y);
    println!("z: {}", z);
}
```

还可以使用 `.` 后面加值的索引来直接访问元组中的值：

```rust
fn main() {
    let tup: (i32, f64, u8) = (24, 2.4, 42);

    let x = tup.0;
    let y = tup.1;
    let z = tup.2;

    println!("x: {}", x);
    println!("y: {}", y);
    println!("z: {}", z);
}
```

#### 2.2.2 数组类型 (Array)

和 Go 一样，Rust 数组中的值的类型也必须一样。和元组一样，数组的长度也是固定的。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

标准库提供了一个与数组类似的 vector 类型，但 vector 可以扩容和缩容。

可以指定数组的类型和长度：

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

还有初始化数组的另一种语法。如果想让数组中的元素值都一样，可以指定初始值和数组长度：

```rust
// 注意，方括号里面是分号
let a: [3; 5];

// 等同于这样写，但更简洁
let a = [3, 3, 3, 3, 3];
```

访问数组元素：数组是在栈上分配的单个内存块，可以使用索引来访问里面的元素。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

非法的数组访问：

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line.");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {} is: {}", index, element);
}
```

输入大于 0 到 4 的数字没问题，超过这个范围的话，会因为运行时错误而 panic：

```bash
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 9', src/main.rs:19:19
```



