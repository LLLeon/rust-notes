# Enums

枚举允许通过列举可能的 **成员**（*variants*） 来定义一个类型。

## 定义枚举

如下：

```rust
fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    // 可以使用任一成员来调用这个函数
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

// 枚举出所有可能的值, IP 地址只能是 V4 和 V6 其中一个成员
enum IpAddrKind {
    V4,
    V6,
}

// 定义一个函数来获取任何 IpAddrKind
fn route(ip_kind: IpAddrKind) {}
```

使用结构体来存储实际 IP 地址 **数据** ：

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

仅使用枚举而不是将枚举类型作为结构体的字段，这种方式更简洁：

```rust
fn main() {
    enum IpAddr {
        V4(String), // 标明成员的类型
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));
}
```

**用枚举替代结构体的一个优势**：每个成员可以处理不同类型和数量的数据。

比如将 IPV4 地址表示为四个 u8 值：

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
}
```

枚举成员可以有多种类型：

```rust
// 枚举类型
enum Message {
    Quit, // 没有关联任何数据
    Move { x: i32, y: i32 }, // 包含一个匿名结构体
    Write(String), // 包含一个 String
    ChangeColor(i32, i32, i32), // 包含三个 i32
}

// 结构体类型
struct QuitMessage; // 类单元结构体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元组结构体
struct ChangeColorMessage(i32, i32, i32); // 元组结构体
```

结构体类型当然可以包含与枚举成员中相同类型的数据，但是这是多个结构体，要实现同样地效果：

- 枚举：函数可以只定义一个枚举类型作为参数。
- 结构体：函数需要定义多个结构体参数作为。

### 为枚举类型定义方法

同结构体一样：

```rust
fn main() {
    let m = Message::Write(String::from("hello"));

    m.Call();
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn Call(&self) {}
}
```

### Option 枚举

`Option` 是标准库定义的一个枚举，它表示**一个值要么有值要么没值**。

Rust 并没有很多其它语言中有的空值功能。**空值**（*Null* ）是一个值，它代表没有值。在有空值的语言中，变量总是这两种状态之一：null 或 not-null.。空值的问题：当尝试像一个非空值那样使用一个空值，会出现某种形式的错误。

Rust 有一个可以编码存在或不存在概念的枚举： `Option<T> ` ，它的定义如下：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

可以不需要 `Option::` 前缀来直接使用 `Some` 和 `None`，但它仍是常规的枚举。示例：

```rust
let some_number = Some(5);
let some_string = Some(String::from("hello"));

// 如果使用 None 而不是 Some，需要告诉 Rust Option<T> 是什么类型的，
// 因为编译器只通过 None 值无法推断出 Some 成员保存的值的类型。
let absent_number: Option<i32> = None;
```

当有个 `None` 值时，在某种意义上它跟空值具有相同的意义：并没有一个有效的值。那么，`Option<T>` 为什么就比空值要好呢？

**因为 `Option<T>` 和 `T`（这里 `T` 可以是任何类型）是不同的类型**，编译器不允许像使用一个肯定有效的值那样使用 `Option<T>`。

例如，这段代码不能编译，因为它尝试将 `Option<i8>` 与 `i8` 相加，而它们的类型不同：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

- 像 `i8` 这样类型的值，编译器**确保它总是有一个有效的值**，可以随意使用而**无需做空值检查**。
- 只有当使用 `Option<T>` 的时候需要担心可能没有值，而编译器会**确保在使用值之前处理了为空的情况**。换句话说，在对 `Option<T>` 进行 `T` 的运算之前必须将其转换为 `T`。

> - 为了拥有一个可能为空的值，必须要**显式的将其放入对应类型的 `Option<T>` 中**。
> - 当使用这个值时，必须明确的处理值为空的情况。
> - 只要一个值不是 `Option<T>` 类型，就 **可以** 安全的认定它的值不为空。

## match 控制流

`match` 表达式是一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。

